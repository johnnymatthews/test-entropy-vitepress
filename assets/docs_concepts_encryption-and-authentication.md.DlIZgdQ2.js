import{_ as e,c as t,o as n,a3 as a}from"./chunks/framework.7ep0oyv4.js";const y=JSON.parse('{"title":"Node Encryption and Authentication","description":"","frontmatter":{},"headers":[],"relativePath":"docs/concepts/encryption-and-authentication.md","filePath":"docs/concepts/encryption-and-authentication.md"}'),o={name:"docs/concepts/encryption-and-authentication.md"},i=a('<h1 id="node-encryption-and-authentication" tabindex="-1">Node Encryption and Authentication <a class="header-anchor" href="#node-encryption-and-authentication" aria-label="Permalink to &quot;Node Encryption and Authentication&quot;">â€‹</a></h1><ul><li><p>When talking to nodes on the Entropy network you need to both authenticate the location of messages and encrypt the messages to said node.</p></li><li><p>The authentication is simple as each node has a substrate account stored on chain referred to as a TSS account (threshold server)</p></li><li><p>Encryption requires using an X25519 public key which gets used in <a href="https://en.wikipedia.org/wiki/ChaCha20-Poly1305" target="_blank" rel="noreferrer">ChaCha20Poly1305</a> process for encryption</p></li><li><p>The concept is simple:</p><ul><li>Whenever you want to authenticate a party you use a substrate key that is tied to them (whether it is a user who made a transaction, or a node who has a TSS account).</li><li>Whenever you want to encrypt a message (only when talking to nodes) you use their X25519PublicKey in the ChaCha20Poly1305 scheme.</li></ul></li></ul>',2),c=[i];function s(r,h,d,p,l,u){return n(),t("div",null,c)}const m=e(o,[["render",s]]);export{y as __pageData,m as default};
