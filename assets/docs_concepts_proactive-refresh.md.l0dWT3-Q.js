import{_ as e,c as t,o as r,a3 as s}from"./chunks/framework.7ep0oyv4.js";const o="/assets/proactive-refresh-sequence-diagram.B_WEmeLt.svg",g=JSON.parse('{"title":"Proactive Refresh","description":"","frontmatter":{},"headers":[],"relativePath":"docs/concepts/proactive-refresh.md","filePath":"docs/concepts/proactive-refresh.md"}'),a={name:"docs/concepts/proactive-refresh.md"},i=s('<h1 id="proactive-refresh" tabindex="-1">Proactive Refresh <a class="header-anchor" href="#proactive-refresh" aria-label="Permalink to &quot;Proactive Refresh&quot;">​</a></h1><ul><li>The concept here is that as validators enter and exit the network their key shares should become invalid</li><li>Every <a href="https://wiki.polkadot.network/docs/glossary#session" target="_blank" rel="noreferrer">session</a> (2400 blocks, which is 4 hours) the chain will inform the TSS servers that a proactive refresh is happening.</li><li>The network (registered keys) will be partitioned as to not refresh the whole network and cause undo strain on the validators.</li><li>One TSS server from each subgroup is selected deterministically using the current block number modulo the number of TSS servers in that subgroup, similar to the selection process for DKG when registering.</li><li>The selected TSS servers (one in each subgroup) will connect to each other and run the proactive refresh protocol, producing a new set of keyshares. The protocol is similar to the distributed key generation protocol used during registration.</li><li>The selected TSS servers send the new keyshares to the other members of their subgroup, and on receiving a keyshare they replace their existing keyshare in their key-value store with the new one.</li><li>All old keyshares will now be incompatible with the refreshed keyshares. But the public validating key of the distributed signing keypair never changes.</li><li>The private access mode, an individual trigger will exist where it is initiated by the user (not yet implemented).</li></ul><p><img src="'+o+'" alt="Proactive Refresh Flow New"></p><h2 id="proactive-refresh-but-i-asked-chatgpt3-to-make-it-sound-like-a-doctor-seuss-book" tabindex="-1">Proactive Refresh but I asked ChatGPT3 to make it sound like a Doctor Seuss book. <a class="header-anchor" href="#proactive-refresh-but-i-asked-chatgpt3-to-make-it-sound-like-a-doctor-seuss-book" aria-label="Permalink to &quot;Proactive Refresh but I asked ChatGPT3 to make it sound like a Doctor Seuss book.&quot;">​</a></h2><p>In the land of networks and validators so grand, A concept arose, quite grand and well planned. As validators entered and left the scene, Their key shares would change, like a magical sheen.</p><p>Each session, the chain would loudly declare, To TSS servers, a message quite rare. A proactive refresh, a dance in the air, Ensuring the keys stayed beyond compare.</p><p>The network, you see, with keys so dear, Was partitioned wisely, with nothing to fear. No need to refresh the whole wide expanse, Lest the validators suffer under the chance.</p><p>Selected validators, with pride and with glee, In each subgroup, refreshed the network, you see. Sending key shares like birds on the wing, To the rest of their subgroups, a harmonious fling.</p><p>Old keys, once so mighty, now lost in the mist, Invalid and gone, in the refresh they exist. An individual trigger, a secret to unfold, For private accounts, a story yet to be told.</p><p>A keyshare held tight by the user&#39;s own hand, A forceful refresh, like a magical wand. Not built just yet, in the code it will be, A tale of networks and keys, as you can see.</p>',10),n=[i];function h(l,c,d,u,p,k){return r(),t("div",null,n)}const v=e(a,[["render",h]]);export{g as __pageData,v as default};
